#include <stdio.h>
#include <stdlib.h>
#define LINE_MAX 1024
struct Process{
    int process_id, arrival_time, cpu_burst, reaming_time,
        waiting_time, turnaround_time, response_time, lastresponse_time;
};
struct Process job_queue[LINE_MAX];
struct Process CPU;
struct Process temp_process;
struct Node{
    struct Process process;
    struct Node *link;
}*head,*tail,*temp,*ptr,*min,*minLink;
void MinProcess();
void queue(struct Process p);
void load_ReadyQueue(int var);
int n,t=0;
double sum=0,sum2=0;
double avg_time,avg_tat;
int SJF();
struct node {
int process, arrival_time , burst_time, ct , waiting_time , turnaround_time ;
struct node *next;
};
struct node *start = NULL;
int FCFS();
void schedulingMethod(void);
void simulationMenu(void);
int main()
{
    simulationMenu();
}
void simulationMenu(){
	int option;
	printf("\t\ CPU Scheduler Simulator \n");
	printf("\n 1) Sheduling method.");
	printf("\n 2) Preemptive Moode.");
	printf("\n 3) Non-preemptive mode.");
	printf("\n 4) Show Results.");
	printf("\n 5) End program.");
   	printf("\n Option >:");

	scanf("%d", &option);
	switch(option){
		case 1:
			schedulingMethod();
			break;
		}
}
void schedulingMethod(void){

	int option;
	printf("\n \t\t\t\tScheduling Methods\n");
	printf("\n 1) First-come First-served.");
   	printf("\n 2) Shortest-Job-first scheduling.");
   	printf("\n 3) Priority scheduling.");
	printf("\n 4) Round-Robin Scheduling.");
	printf("\n 5) Go back to main menu.");
	printf("\n 6) Close.");
    printf("\n Option >:");

	scanf("%d",&option);

	switch(option){
		case 1:
			FCFS();
			break;
		case 2:
			SJF();
			break;
	}	

}
int SJF(){

int i,j;
    int loop_time;


FILE *fp;
char line[LINE_MAX];
unsigned int num[3];

if ((fp = fopen("filename.txt", "r")) == NULL)
        return 0;


while (fgets(line, LINE_MAX, fp) != NULL) {
        sscanf(line,"%d:%d:%d\n",&num[0],&num[1],&num[2]);
        job_queue[i].arrival_time = num[1];
        job_queue[i].cpu_burst = num[0];
        job_queue[i].process_id=i+1;
        job_queue[i].reaming_time=job_queue[i].cpu_burst;
        t=t+job_queue[i].cpu_burst;
        i++;

    }
    n=i;
    fclose(fp);
    for(j=0;j<t;j++){
        load_ReadyQueue(j);
        if(CPU.reaming_time==0){
            MinProcess();
            if(min==NULL){
                printf("|IDLE|");
            }else{
                CPU=min->process;
                CPU.lastresponse_time=j;
                if(CPU.cpu_burst==CPU.reaming_time){
                CPU.response_time=j;
                }
                if(min==head && min==tail){
                    head=NULL;
                    tail=NULL;
                    free(min);
                }else if(min==head && min!=tail){
                    head=min->link;
                    free(min);
                }else if(min==tail && min!=head){
                    minLink=head;
                    ptr=head;
                    while(ptr->link!=NULL){
                        minLink=ptr;
                        ptr=ptr->link;
                    }
                    tail=minLink;
                    minLink->link=NULL;
                    free(min);
                    minLink=NULL;
                }else if(min!=head && min!=tail){
                    minLink=head;
                    ptr=head;
                    while(ptr->link!=min){
                        minLink=ptr;
                        ptr=ptr->link;
                    }
                    minLink->link=min->link;
                    free(min);
                    minLink=NULL;
                }
                CPU.reaming_time--;


            }
        }else if(CPU.reaming_time>0){
            MinProcess();
            if(min!=NULL && min->process.reaming_time < CPU.reaming_time){
                    if(min==head && min==tail){
                        temp_process=CPU;
                        head=NULL;
                        tail=NULL;
                        CPU=min->process;
                        CPU.lastresponse_time=j;
                         if(CPU.cpu_burst==CPU.reaming_time){
                          CPU.response_time=j;
                           }
                        CPU.reaming_time--;

                        free(min);
                        queue(temp_process);
                    }else if(min==head && min!=tail){
                        temp_process=CPU;
                        head=min->link;
                        CPU=min->process;
                        CPU.lastresponse_time=j;
                           if(CPU.response_time==0){
                            CPU.response_time=j;
                             }
                        CPU.reaming_time--;

                        free(min);
                        queue(temp_process);
                    }else if(min!=head && min==tail){
                        minLink=head;
                        ptr=head;
                        while(ptr->link!=NULL){
                            minLink=ptr;
                            ptr=ptr->link;
                        }
                        temp_process=CPU;
                        CPU=min->process;
                        CPU.lastresponse_time=j;
                        if(CPU.cpu_burst==CPU.reaming_time){
                         CPU.response_time=j;
                         }
                        tail=minLink;
                        minLink->link=NULL;
                        CPU.reaming_time--;

                        free(min);
                        queue(temp_process);
                    }else{
                        minLink=head;
                        ptr=head;
                        while(ptr->link!=min){
                            minLink=ptr;
                            ptr=ptr->link;
                        }
                        temp_process=CPU;
                        CPU=min->process;
                        CPU.lastresponse_time=j;
                        if(CPU.cpu_burst==CPU.reaming_time){
                          CPU.response_time=j;
                          }
                        minLink->link=min->link;
                        CPU.reaming_time--;

                        free(min);
                        queue(temp_process);
                    }

            }else{
                CPU.reaming_time--;

            }

        }
        if(CPU.reaming_time==0){
            job_queue[CPU.process_id-1].turnaround_time=j-job_queue[CPU.process_id-1].arrival_time+1;
            job_queue[CPU.process_id-1].waiting_time=job_queue[CPU.process_id-1].turnaround_time-job_queue[CPU.process_id-1].cpu_burst;
            job_queue[CPU.process_id-1].response_time=CPU.response_time;
            job_queue[CPU.process_id-1].lastresponse_time=CPU.lastresponse_time;
        }

    }
    FILE * fp2;


   fp2 = fopen ("output1.txt","w");
   fprintf (fp2, "Scheduling Method:\n");
 fprintf (fp2, "Process Waiting Times:\n");

    for(i=0;i<n;i++){
        fprintf(fp2, "P%d:\t%d ms\n",job_queue[i].process_id,job_queue[i].waiting_time);
        sum=sum+job_queue[i].waiting_time;
        sum2=sum2+job_queue[i].turnaround_time;
    }
    avg_time=sum/n;
    avg_tat=sum2/n;

    fprintf(fp2, "Average waiting time: %lf\n",avg_time);
    printf("Simulation complete. Output printed in output1.txt\n");
    simulationMenu();
    return 0;
}


void queue(struct Process p){

    if(tail==NULL){
        temp=(struct Node *)malloc(1*sizeof(struct Node));
        temp->link=NULL;
        temp->process=p;
        head=temp;
        tail=head;
    }else{
        temp = (struct Node *)malloc(1*sizeof(struct Node));
        tail->link=temp;
        temp->process=p;
        temp->link=NULL;
        tail=temp;
    }
}

void MinProcess()
{
    ptr=head;

    if(ptr==NULL){
        min=NULL;
        return;
    }
      min = head;
    for (ptr=ptr->link;ptr!=NULL;ptr=ptr->link)
    {
        if(ptr->process.reaming_time < min->process.reaming_time){
            min=ptr;
        }else if(ptr->process.reaming_time==min->process.reaming_time){
            if(ptr->process.process_id < min->process.process_id){
                min=ptr;
            }
        }else {

        }
    }

}

void load_ReadyQueue(int var){
    int i;
    for(i=0;i<n;i++){
        if(job_queue[i].arrival_time==var){
            queue(job_queue[i]);
        }
    }


}
int FCFS(){

int i ,j , temp , c;
float avgw = 0.0;
struct node *ptr , *newnode , *preptr ;
int x = 0;

FILE *fp;
char line[LINE_MAX];
unsigned int num[3];

if ((fp = fopen("filename.txt", "r")) == NULL)
        return 0;

        
while (fgets(line, LINE_MAX, fp) != NULL) {
        sscanf(line,"%d:%d:%d\n",&num[0],&num[1],&num[2]);
       	newnode = (struct node*) malloc(sizeof(struct node));
		newnode->arrival_time = num[1];
		newnode->burst_time = num[0];
		newnode->next = NULL;

if(start == NULL){

start = newnode;

ptr = start;

}

else {

ptr->next = newnode;

ptr = ptr->next;

}
x++;
 		
}
fclose(fp);


ptr = start;

i = 1;

while(ptr!=NULL){

ptr->process = i ;

ptr = ptr->next;

i++;

}

ptr = start;


while(ptr->next!=NULL){

preptr = ptr->next;

while(preptr!=NULL){

if (ptr->arrival_time > preptr->arrival_time){

temp = ptr->arrival_time;

ptr->arrival_time = preptr->arrival_time;

preptr->arrival_time = temp;

temp = ptr->burst_time;

ptr->burst_time = preptr->burst_time;

preptr->burst_time = temp;

temp = ptr->process;

ptr->process = preptr->process;

preptr->process= temp;

}

preptr = preptr ->next;

}

ptr = ptr->next;

}

ptr = start;





ptr = start;

c = ptr->arrival_time ;

while(ptr!=NULL){

ptr->ct = c + ptr->burst_time;

c = ptr->ct;

ptr->turnaround_time = ptr->ct - ptr->arrival_time;

ptr->waiting_time = ptr->turnaround_time - ptr->burst_time;

ptr = ptr->next;

}


ptr = start;

while(ptr != NULL){



avgw = avgw + ptr->waiting_time;

ptr = ptr->next;

}

FILE * fp2;
   
  
   fp2 = fopen ("output1.txt","w");
 fprintf (fp2, "Process Waiting Times:\n");
   
   for(i=1;i<=x;i++){

ptr = start;

while(ptr!=NULL){

if(ptr->process == i)
 

fprintf(fp2, "P%d:\t%d ms\n",ptr->process,ptr->waiting_time);

ptr = ptr->next;

}

}
       fprintf (fp2, "Averge Waiting time %f",avgw/x); 
   fclose (fp2);
   
   printf("Simulation complete. Output printed in output1.txt\n");
   simulationMenu();
}



